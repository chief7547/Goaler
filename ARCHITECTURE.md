# Goaler 프로젝트 아키텍처

이 문서는 Goaler 프로젝트의 핵심 아키텍처, 설계 원칙, 그리고 개발 워크플로우를 설명합니다.

## 0. 개발 접근 전략: 핵심 로직 선행 구현 및 검증

본격적인 앱 기능(UI, DB 연동 등)과 LLM 연동을 구현하기에 앞서, 우리는 가장 불확실성이 높은 부분인 **'대화형으로 목표를 설정하는 비즈니스 로직'의 구현 가능성을 먼저 검증**하는 전략을 선택했습니다.

이를 위해, 외부 라이브러리나 UI에 대한 의존성 없이, 순수한 파이썬 코드로 `GoalSettingAgent`라는 핵심 로직을 **테스트 주도 개발(TDD) 방식으로 선행 구현**했습니다.

이 접근 방식의 목적은 다음과 같습니다:

1.  **기술적 타당성 검증:** LLM과의 대화를 통해 목표를 생성하고, 지표를 추가하며, 상태를 관리하는 복잡한 로직을 실제로 구현할 수 있는지 확인합니다.
2.  **안정적인 기반 구축:** LLM이라는 '두뇌'가 생기기 전에, 먼저 튼튼하고 테스트로 검증된 '몸통'을 만듭니다. 이렇게 하면, 나중에 LLM을 연동할 때 발생하는 문제를 순수하게 '연동'의 문제로 좁힐 수 있습니다.

이 문서의 나머지 부분은 이 전략에 따라 `core` 로직을 구현하고, 그 후 LLM 연동을 시도했던 과정을 상세히 설명합니다.

## 1. 핵심 철학: 대화형 목표 설정

초기 `VIBECODE_ENTRY.md`의 인터뷰 방식은 정적인 질문/답변으로 구성되어 복잡하고 유연한 목표 설정을 구현하기에 한계가 있었습니다.

따라서, 우리는 사용자와의 자연스러운 대화를 통해 목표를 구체화하고, 지표를 추가/수정하며, 동기를 부여하는 **대화형 목표 설정(Conversational Goal-Setting)** 방식을 핵심 철학으로 채택했습니다. 이 방식은 LLM의 Function Calling(Tool-use) 능력을 기반으로 하며, 사용자가 복잡한 폼을 채울 필요 없이 AI 코치와 대화하듯 목표를 설정하는 경험을 제공합니다.

## 2. 주요 구성 요소 (`core` 디렉토리)

대화형 목표 설정을 구현하기 위한 핵심 로직은 `core` 디렉토리 안에 캡슐화되어 있습니다.

- **`core/agent.py` (`GoalSettingAgent`):**
  - 전체 대화 과정을 오케스트레이션하는 **총괄 지휘자**입니다.
  - `StateManager`를 소유하여 대화의 '상태'를 관리합니다.
  - `create_goal`, `add_metric` 등 LLM이 호출할 수 있는 실제 비즈니스 로직을 메소드로 포함합니다.

- **`core/state_manager.py` (`StateManager`):**
  - 대화가 진행되는 동안 사용자의 목표 설정 내용을 임시로 저장하는 **단기 기억 장치**입니다.
  - 각 대화별로 상태를 분리하여 관리하며, 대화가 완료되면 상태를 삭제합니다.
  - 현재는 메모리 내 딕셔너리로 구현되어 있으나, 향후 Redis 등으로 확장될 수 있습니다.

- **`core/llm_prompt.py`:**
  - LLM 에이전트의 행동을 정의하는 **지시문(Instruction)과 도구(Tool) 명세서**입니다.
  - `SYSTEM_PROMPT`는 LLM의 페르소나, 역할, 규칙(예: 모호할 경우 되묻기)을 정의합니다.
  - `create_goal` 등의 함수 시그니처는 LLM에게 어떤 도구를 사용할 수 있는지 알려주는 API 계약(Contract) 역할을 합니다.

## 3. 대화형 목표 설정 워크플로우

1.  **사용자 입력:** 사용자가 "새로운 목표를 만들고 싶어"와 같이 대화를 시작합니다.
2.  **LLM 의도 파악:** LLM은 `SYSTEM_PROMPT`와 함수 명세를 바탕으로 사용자의 의도를 파악합니다. (예: `create_goal` 함수 호출 필요)
3.  **함수 호출 (Function Calling):** LLM은 텍스트 대신, 실행해야 할 함수(예: `agent.create_goal(...)`)를 특정 형식으로 반환합니다.
4.  **에이전트 실행:** 애플리케이션은 LLM의 함수 호출 요청을 받아, `GoalSettingAgent`의 해당 메소드를 실행합니다.
5.  **상태 변경:** 에이전트의 메소드는 `StateManager`를 통해 현재 대화의 상태를 변경(생성, 수정)합니다.
6.  **LLM 응답 생성:** 에이전트는 실행 결과를 바탕으로 LLM에게 다음 응답 생성을 요청합니다. (예: "목표가 생성되었습니다. 어떤 지표를 추가할까요?")
7.  **응답 및 반복:** LLM의 응답이 사용자에게 전달되고, 사용자가 목표 설정을 완료할 때까지 위 과정이 반복됩니다.

## 4. 개발 및 테스트 전략

- **테스트 주도 개발 (TDD):** `core` 디렉토리의 모든 기능은 TDD 방식으로 개발됩니다. `tests/test_core.py`에 실패하는 테스트를 먼저 작성하고, 이를 통과시키는 코드를 `core`에 구현합니다.
- **단위 테스트:** 모든 에이전트의 메소드는 각 기능이 독립적으로 정확히 동작하는지 검증하는 단위 테스트를 가져야 합니다.
- **CI 연동:** 모든 테스트는 `pytest`를 통해 실행되며, GitHub Actions CI 파이프라인에 통합되어 코드 변경 시 항상 자동 검증됩니다.

## 5. LLM 연동 디버깅 기록 및 교훈

이 섹션은 `app.py`의 대화 루프를 구현하는 과정에서 발생한 문제와 해결 과정을 기록하여, 다음 작업자에게 컨텍스트를 제공합니다.

### 5.1. Google Gemini API 시도

- **문제:** `google-genai` 라이브러리를 사용하여 `Tool`을 정의하는 과정에서, 라이브러리 내부의 `Schema` 및 `Type` 객체를 참조할 수 없는 `AttributeError` 또는 `ImportError`가 반복적으로 발생했습니다.
- **원인 분석:** 설치된 라이브러리 버전과 공식 문서 간의 미세한 불일치로 추정됩니다. `dir()`을 통해 라이브러리를 직접 검사한 결과, 문서와 다른 내부 구조를 가지고 있음을 확인했습니다.
- **결론:** 외부에서 제어할 수 없는 라이브러리 내부의 비일관성 문제로, Google Gemini API 연동을 중단하고 대안을 모색하기로 결정했습니다.

### 5.2. OpenAI API 시도

- **전환:** 대안으로 `openai` 라이브러리와 `gpt-4o`, `gpt-5-mini` 모델을 사용하도록 전환했습니다.
- **문제 1: `RateLimitError` (사용량 초과):** 초기 API 호출 시, 사용자의 OpenAI 계정에 결제 정보가 등록되지 않아 발생했습니다.
- **해결:** 사용자께서 직접 결제 정보를 등록하고 크레딧을 충전하여 해결했습니다. 이를 통해 API 키 자체는 유효함을 확인했습니다.
- **문제 2: 빈 응답 (Empty Response):** 결제 문제 해결 후, API 호출 시 에러는 발생하지 않으나 LLM이 아무런 텍스트나 함수 호출 없이 '빈 응답'을 반환하는 현상이 발생했습니다. 이는 가장 간단한 "안녕"이라는 인사 테스트에서도 동일하게 나타났습니다.
- **최종 결론:** 코드의 모든 논리적 오류를 수정하고, 가장 단순한 형태로 API를 호출했음에도 문제가 지속되는 것으로 보아, 이는 코드의 문제가 아닌 **실행 환경(네트워크, 방화벽 등)과 OpenAI 서버 간의 특수한 통신 문제**이거나, **API 계정의 특수한 설정** 문제일 가능성이 매우 높습니다.

### 5.3. 다음 작업자를 위한 제안

1.  **핵심 로직은 안정적임:** `core` 디렉토리의 `GoalSettingAgent`와 관련 로직은 TDD를 통해 완벽하게 검증된 상태입니다.
2.  **환경 문제 우선 확인:** LLM 연동을 다시 시도하기 전에, **다른 네트워크 환경(예: 로컬 PC, 다른 클라우드 VM)에서 `app.py`를 실행**하여, 현재 환경의 특수 문제인지 먼저 확인하는 것을 강력히 권장합니다.