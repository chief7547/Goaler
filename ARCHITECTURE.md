# Goaler 프로젝트 아키텍처

이 문서는 Goaler 프로젝트의 핵심 아키텍처, 설계 원칙, 그리고 개발 워크플로우를 설명합니다.

## 0. 개발 접근 전략: 핵심 로직을 먼저 탄탄하게

이 프로젝트는 “대화만으로 목표를 정의하고 완성할 수 있는가?”라는 질문에서 시작했습니다. 그래서 UI나 데이터베이스를 붙이기 전에, **목표를 단계별로 조립하는 비즈니스 로직**을 TDD로 먼저 만들고 충분히 검증했습니다. 이렇게 해 두니, 나중에 챗봇이 GPT를 통해 어떤 메시지를 보내더라도 결국 믿고 맡길 수 있는 코어가 생겼습니다.

## 1. 핵심 철학: 대화형 목표 설정

초기 `VIBECODE_ENTRY.md`의 인터뷰 방식은 정적인 질문/답변으로 구성되어 복잡하고 유연한 목표 설정을 구현하기에 한계가 있었습니다.

따라서, 우리는 사용자와의 자연스러운 대화를 통해 목표를 구체화하고, 지표를 추가/수정하며, 동기를 부여하는 **대화형 목표 설정(Conversational Goal-Setting)** 방식을 핵심 철학으로 채택했습니다. 이 방식은 LLM의 Function Calling(Tool-use) 능력을 기반으로 하며, 사용자가 복잡한 폼을 채울 필요 없이 AI 코치와 대화하듯 목표를 설정하는 경험을 제공합니다.

## 2. 주요 구성 요소 (`core` 디렉토리)

대화형 목표 설정을 구현하기 위한 핵심 로직은 `core` 디렉토리 안에 캡슐화되어 있습니다.

- **`core/agent.py` (`GoalSettingAgent`):**
  - 전체 대화 과정을 오케스트레이션하는 **총괄 지휘자**입니다.
  - `StateManager`를 소유하여 대화의 '상태'를 관리합니다.
  - `create_goal`, `add_metric` 등 LLM이 호출할 수 있는 실제 비즈니스 로직을 메소드로 포함합니다.

- **`core/state_manager.py` (`StateManager`):**
  - 대화가 진행되는 동안 사용자의 목표 설정 내용을 임시로 저장하는 **단기 기억 장치**입니다.
  - 각 대화별로 상태를 분리하여 관리하며, 대화가 완료되면 상태를 삭제합니다.
  - 현재는 메모리 내 딕셔너리로 구현되어 있으나, 향후 Redis 등으로 확장될 수 있습니다.

- **`core/llm_prompt.py`:**
  - LLM 에이전트의 행동을 정의하는 **지시문(Instruction)과 도구(Tool) 명세서**입니다.
  - `SYSTEM_PROMPT`는 LLM의 페르소나, 역할, 규칙(예: 모호할 경우 되묻기)을 정의합니다.
  - `create_goal` 등의 함수 시그니처는 LLM에게 어떤 도구를 사용할 수 있는지 알려주는 API 계약(Contract) 역할을 합니다.

## 3. 대화형 목표 설정 워크플로우

1.  **사용자 입력:** 사용자가 "새로운 목표를 만들고 싶어"와 같이 대화를 시작합니다.
2.  **LLM 의도 파악:** LLM은 `SYSTEM_PROMPT`와 함수 명세를 바탕으로 사용자의 의도를 파악합니다. (예: `create_goal` 함수 호출 필요)
3.  **함수 호출 (Function Calling):** LLM은 텍스트 대신, 실행해야 할 함수(예: `agent.create_goal(...)`)를 특정 형식으로 반환합니다.
4.  **에이전트 실행:** 애플리케이션은 LLM의 함수 호출 요청을 받아, `GoalSettingAgent`의 해당 메소드를 실행합니다.
5.  **상태 변경:** 에이전트의 메소드는 `StateManager`를 통해 현재 대화의 상태를 변경(생성, 수정)합니다.
6.  **LLM 응답 생성:** 에이전트는 실행 결과를 바탕으로 LLM에게 다음 응답 생성을 요청합니다. (예: "목표가 생성되었습니다. 어떤 지표를 추가할까요?")
7.  **응답 및 반복:** LLM의 응답이 사용자에게 전달되고, 사용자가 목표 설정을 완료할 때까지 위 과정이 반복됩니다.

## 4. 데이터 저장 전략 (MVP → 확장 단계)

- **MVP (개발 환경/소규모 사용자)**
  - SQLite를 기본 저장소로 채택합니다. 추가 인프라 없이 파일 하나로 목표와 대화 상태를 영구 보관할 수 있으며, 파이썬 표준 라이브러리(`sqlite3`)만으로 구현 가능합니다.
  - `StateManager`의 저장/조회 로직을 저장소 어댑터로 분리해 두면, 인메모리 → SQLite 전환을 코드 변경 최소화로 맞출 수 있습니다.

- **서비스 단계 (정식 배포/확장)**
  - PostgreSQL 같은 서버형 RDBMS로 전환합니다. SQL 문법이 SQLite와 동일 계열이어서 마이그레이션 비용이 낮고, 사용자 수가 늘어도 안정적으로 동작합니다.
  - 환경 변수(예: `GOALER_DATABASE_URL`)로 연결 문자열을 주입하고, ORM(SQLAlchemy 등)을 사용하면 저장소 교체가 더욱 쉬워집니다.

- **문서 및 템플릿 연계**
  - `README.md`와 `VIBECODE_ENTRY.md` 템플릿에 “개발: SQLite / 배포: PostgreSQL” 흐름을 명시해 CLI가 생성하는 문서도 같은 전략을 반영하도록 합니다.

## 5. 개발 및 테스트 전략

- **테스트 주도 개발 (TDD):** `core` 디렉토리의 기능은 TDD 방식으로 개발합니다. 실패하는 테스트부터 작성하고 이를 통과시키는 코드를 구현합니다.
- **단위 테스트:** 목표 생성, 메트릭 추가, 동기 설정 등 핵심 기능이 독립적으로 정확히 동작하는지 검증합니다.
- **CI 연동:** GitHub Actions에서 `lint`, `typecheck`, `pytest`, `golden-check` job을 분리해 실행합니다. 네 가지 상태 모두 초록불일 때만 브랜치 머지가 가능하도록 브랜치 보호 규칙을 설정합니다.

## 6. GPT 연동 현황과 교훈

- **현재 상태:** `GOALER_USE_MOCK=false`로 실행하면 GPT 모델이 실제로 `create_goal → add_metric → set_motivation → finalize_goal` 순서로 함수를 호출합니다. 메트릭 정보를 여러 형식으로 보내도 `GoalSettingAgent`가 알아서 정리한 뒤 상태를 갱신합니다.
- **Mock 모드:** 기본값은 mock 모드입니다. 덕분에 네트워크가 막혀 있어도 언제든지 흐름을 시연하거나 테스트할 수 있습니다.
- **교훈:** 초기에 다른 모델(Gemini 등)을 검토했지만 라이브러리 안정성이 떨어졌습니다. 반면 OpenAI SDK는 툴 호출 포맷만 정확히 맞추면 안정적으로 응답을 반환하므로, 현재 구조는 GPT 계열 모델을 전제로 설계되어 있습니다.

## 7. 앞으로의 진화 방향

1. **경험 확장:** CLI 기반 데모를 웹/모바일 UI나 메시징 챗봇으로 옮겨 사용자가 목표 카드를 시각적으로 확인할 수 있게 만듭니다.
2. **지속 저장:** 지금은 인메모리 상태이므로, 목표를 DB나 파일에 저장해 다시 접속했을 때 이어서 대화할 수 있도록 합니다.
3. **코칭 콘텐츠 강화:** 목표 유형별 질문 템플릿, 행동 제안, 주간 피드백 루틴 등을 추가하면 “코치”라는 색깔이 더 선명해집니다.
4. **자동 리마인더:** 캘린더·슬랙·문자 등과 연동해 사용자가 정한 측정 주기에 맞춰 체크인을 요청하도록 확장합니다.

## 8. 코칭 철학과 장기 목표 지원

- Goaler는 단순한 일상 습관뿐 아니라 “1년 뒤 마라톤 완주”, “1년 안에 사이드 프로젝트로 월 매출 100만 원” 같은 **장기·비전형 목표**를 포기하지 않고 달성하도록 돕는 데 초점을 둡니다.
- 심리학/게이미피케이션 요소를 도입해 목표 진행률을 게임처럼 느끼도록 설계합니다. 예: 단계별 퀘스트, 주간 리포트, 축하 메시지 등.
- 인터뷰 질문(`CLARIFIERS.md`), 시스템 프롬프트, 테스트 시나리오가 이러한 철학을 공유하도록 문서를 지속적으로 보강합니다.
